#!/usr/bin/env bash
set -euo pipefail

forest_dir="${TEMPTREE_FOREST_DIR:-$HOME/forest}"

usage() {
  cat <<'USAGE'
Usage: temptree [options] [ref]

Creates a temporary git worktree and COW-copies the entire working tree into it.
If ref is omitted, HEAD is used. The worktree is detached at the given ref, then
file contents are copied from the current working tree (uncommitted changes
included). The ref controls what git history is visible, not the file contents.

Options:
  -n, --name <name>   Directory suffix (instead of a random number)
  -d, --dir <path>    Worktree directory (cannot combine with -n)
  --dry-run           Show what would be done without doing it
  -h, --help          Show this help
USAGE
}

die() {
  echo "error: $1" >&2
  exit 1
}

[[ -z "${TEMPTREE_FOREST_DIR:-}" || "$forest_dir" == /* ]] \
  || die "TEMPTREE_FOREST_DIR must be an absolute path"

repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" \
  || die "not inside a git repository"
main_worktree="$(git worktree list --porcelain | head -1)"
main_worktree="${main_worktree#worktree }"
repo_name="$(basename "$main_worktree")"

worktree_dir=""
name=""
ref="HEAD"
dry_run=false
positional=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    -n|--name)
      [[ -n "${2:-}" ]] || die "--name requires a value"
      name="$2"; shift 2 ;;
    -d|--dir)
      [[ -n "${2:-}" ]] || die "--dir requires a path"
      worktree_dir="$2"; shift 2 ;;
    --dry-run) dry_run=true; shift ;;
    --) shift; break ;;
    -*) die "unknown option: $1" ;;
    *) positional+=("$1"); shift ;;
  esac
done
positional+=("$@")

case "${#positional[@]}" in
  0) ;;
  1) ref="${positional[0]}" ;;
  2)
    ref="${positional[0]}"
    [[ -z "$worktree_dir" ]] || die "cannot specify directory both as argument and with --dir"
    worktree_dir="${positional[1]}"
    ;;
  *) die "too many arguments" ;;
esac

[[ -z "$name" || -z "$worktree_dir" ]] \
  || die "--name and --dir cannot be used together"

[[ -z "$name" || "$name" != */* ]] \
  || die "name must not contain '/'"

if [[ -n "$worktree_dir" && "$worktree_dir" != /* ]]; then
  worktree_dir="$(pwd)/$worktree_dir"
fi

created=false
completed=false

cleanup() {
  if [[ "$created" == "true" && "$completed" == "false" ]]; then
    git -C "$repo_root" worktree remove --force "$worktree_dir" >/dev/null 2>&1 || true
  fi
}

trap cleanup EXIT INT TERM

if [[ -z "$worktree_dir" ]]; then
  mkdir -p "$forest_dir"
  if [[ -n "$name" ]]; then
    worktree_dir="$forest_dir/${repo_name}-${name}"
    [[ ! -e "$worktree_dir" ]] || die "$worktree_dir already exists"
  else
    attempts=0
    while :; do
      rand="$(printf '%04d' $((RANDOM % 10000)))"
      worktree_dir="$forest_dir/${repo_name}-${rand}"
      [[ -e "$worktree_dir" ]] || break
      ((attempts++))
      [[ "$attempts" -lt 100 ]] || die "could not find a free name after $attempts attempts"
    done
  fi
else
  if [[ -e "$worktree_dir" ]]; then
    if [[ ! -d "$worktree_dir" ]]; then
      die "$worktree_dir exists and is not a directory"
    elif [[ -n "$(ls -A "$worktree_dir")" ]]; then
      die "$worktree_dir exists and is not empty"
    fi
  fi
fi

if [[ "$dry_run" == "true" ]]; then
  echo "would create worktree at $worktree_dir (ref: $ref, source: $repo_root)" >&2
  exit 0
fi

if ! git -C "$repo_root" worktree add --detach -- "$worktree_dir" "$ref" >/dev/null 2>&1; then
  die "failed to create worktree (is '$ref' a valid ref?)"
fi
created=true

(
  shopt -s dotglob nullglob
  GLOBIGNORE=".git"
  cd "$repo_root"
  files=(*)
  if [[ "${#files[@]}" -eq 0 ]]; then
    exit 0
  fi
  if cp -cpR -- "${files[@]}" "$worktree_dir"/ 2>/dev/null; then
    :
  elif cp --reflink=auto -a -- "${files[@]}" "$worktree_dir"/ 2>/dev/null; then
    :
  else
    cp -a -- "${files[@]}" "$worktree_dir"/
  fi
)

completed=true
printf '%s\n' "$worktree_dir"
