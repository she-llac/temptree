#!/usr/bin/env bash
set -euo pipefail

forest_dir="${TEMPTREE_FOREST_DIR:-$HOME/forest}"

usage() {
  cat <<'USAGE'
Usage: temptree [options]

Creates a temporary git worktree at HEAD and COW-copies the entire working tree
into it (uncommitted changes included). Your main checkout stays untouched.

Options:
  -n, --name <name>   Directory suffix (instead of a random number)
  -d, --dir <path>    Worktree directory (cannot combine with -n)
  --dry-run           Show what would be done without doing it
  -h, --help          Show this help
USAGE
}

die() {
  echo "error: $1" >&2
  exit 1
}

[[ -z "${TEMPTREE_FOREST_DIR:-}" || "$forest_dir" == /* ]] \
  || die "TEMPTREE_FOREST_DIR must be an absolute path"

case "${1:-}" in -h|--help) usage; exit 0 ;; esac

repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" \
  || die "not inside a git repository"
main_worktree="$(git worktree list --porcelain | head -1)"
main_worktree="${main_worktree#worktree }"
repo_name="$(basename "$main_worktree")"

worktree_dir=""
name=""
dry_run=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    -n|--name)
      [[ -n "${2:-}" ]] || die "--name requires a value"
      name="$2"; shift 2 ;;
    -d|--dir)
      [[ -n "${2:-}" ]] || die "--dir requires a path"
      worktree_dir="$2"; shift 2 ;;
    --dry-run) dry_run=true; shift ;;
    --) shift; break ;;
    -*) die "unknown option: $1" ;;
    *) die "unexpected argument: $1" ;;
  esac
done
[[ $# -eq 0 ]] || die "unexpected argument: $1"

[[ -z "$name" || -z "$worktree_dir" ]] \
  || die "--name and --dir cannot be used together"

[[ -z "$name" || "$name" != */* ]] \
  || die "name must not contain '/'"

if [[ -n "$worktree_dir" && "$worktree_dir" != /* ]]; then
  worktree_dir="$(pwd)/$worktree_dir"
fi

created=false
completed=false

cleanup() {
  if [[ "$created" == "true" && "$completed" == "false" ]]; then
    git -C "$repo_root" worktree remove --force "$worktree_dir" >/dev/null 2>&1 || true
  fi
}

trap cleanup EXIT INT TERM

if [[ -z "$worktree_dir" ]]; then
  [[ "$dry_run" == "true" ]] || mkdir -p "$forest_dir"
  if [[ -n "$name" ]]; then
    worktree_dir="$forest_dir/${repo_name}-${name}"
    [[ ! -e "$worktree_dir" ]] || die "$worktree_dir already exists"
  else
    attempts=0
    while :; do
      rand="$(printf '%04d' $((RANDOM % 10000)))"
      worktree_dir="$forest_dir/${repo_name}-${rand}"
      [[ -e "$worktree_dir" ]] || break
      ((attempts++))
      [[ "$attempts" -lt 100 ]] || die "could not find a free name after $attempts attempts"
    done
  fi
else
  if [[ -e "$worktree_dir" ]]; then
    if [[ ! -d "$worktree_dir" ]]; then
      die "$worktree_dir exists and is not a directory"
    elif [[ -n "$(ls -A "$worktree_dir")" ]]; then
      die "$worktree_dir exists and is not empty"
    fi
  fi
fi

if [[ "$dry_run" == "true" ]]; then
  echo "would create worktree at $worktree_dir (source: $repo_root)" >&2
  exit 0
fi

if ! git -C "$repo_root" worktree add --detach -- "$worktree_dir" HEAD >/dev/null 2>&1; then
  die "failed to create worktree"
fi
created=true

(
  shopt -s dotglob nullglob
  GLOBIGNORE=".git"
  cd "$repo_root"
  files=(*)
  if [[ "${#files[@]}" -eq 0 ]]; then
    exit 0
  fi
  if cp -cpR -- "${files[@]}" "$worktree_dir"/ 2>/dev/null; then
    :
  elif cp --reflink=auto -a -- "${files[@]}" "$worktree_dir"/ 2>/dev/null; then
    :
  else
    cp -a -- "${files[@]}" "$worktree_dir"/
  fi
)

completed=true
printf '%s\n' "$worktree_dir"
