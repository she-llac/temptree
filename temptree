#!/usr/bin/env bash
set -euo pipefail

forest_dir="${TEMPTREE_FOREST_DIR:-$HOME/forest}"

usage() {
  cat <<'USAGE'
Usage: temptree [options] [ref]

Creates a temporary git worktree and COW-copies the entire working tree into it.
If ref is omitted, HEAD is used. The worktree is detached at the given ref, then
file contents are copied from the current working tree (uncommitted changes
included). The ref controls what git history is visible, not the file contents.

Options:
  -n, --name <name>  Directory suffix (instead of a random number)
  -d, --dir <path>   Worktree directory (cannot combine with -n)
  -h, --help          Show this help
USAGE
}

die() {
  echo "error: $1" >&2
  exit 1
}

[[ -z "${TEMPTREE_FOREST_DIR:-}" || "$forest_dir" == /* ]] \
  || die "TEMPTREE_FOREST_DIR must be an absolute path"

repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" \
  || die "not inside a git repository"
main_worktree="$(git worktree list --porcelain | head -1)"
main_worktree="${main_worktree#worktree }"
repo_name="$(basename "$main_worktree")"

worktree_dir=""
name=""
ref="HEAD"
positional=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    -n|--name)
      [[ -n "${2:-}" ]] || die "--name requires a value"
      name="$2"; shift 2 ;;
    -d|--dir)
      [[ -n "${2:-}" ]] || die "--dir requires a path"
      worktree_dir="$2"; shift 2 ;;
    -*) die "unknown option: $1" ;;
    *) positional+=("$1"); shift ;;
  esac
done

case "${#positional[@]}" in
  0) ;;
  1) ref="${positional[0]}" ;;
  2)
    ref="${positional[0]}"
    [[ -z "$worktree_dir" ]] || die "cannot specify directory both as argument and with --dir"
    worktree_dir="${positional[1]}"
    ;;
  *) die "too many arguments" ;;
esac

[[ -z "$name" || -z "$worktree_dir" ]] \
  || die "--name and --dir cannot be used together"

created=false
completed=false

cleanup() {
  if [[ "$created" == "true" && "$completed" == "false" ]]; then
    git -C "$repo_root" worktree remove --force "$worktree_dir" >/dev/null 2>&1 || true
  fi
}

trap cleanup EXIT INT TERM

if [[ -z "$worktree_dir" ]]; then
  mkdir -p "$forest_dir"
  if [[ -n "$name" ]]; then
    worktree_dir="$forest_dir/${repo_name}-${name}"
    [[ ! -e "$worktree_dir" ]] || die "$worktree_dir already exists"
  else
    while :; do
      rand="$(printf '%04d' $((RANDOM % 10000)))"
      worktree_dir="$forest_dir/${repo_name}-${rand}"
      [[ -e "$worktree_dir" ]] || break
    done
  fi
else
  if [[ -e "$worktree_dir" ]]; then
    [[ -d "$worktree_dir" && -z "$(ls -A "$worktree_dir")" ]] \
      || die "$worktree_dir exists and is not empty"
  fi
fi

if ! git -C "$repo_root" worktree add --detach "$worktree_dir" "$ref" >/dev/null 2>&1; then
  die "failed to create worktree (is '$ref' a valid ref?)"
fi
created=true

(
  shopt -s dotglob nullglob
  GLOBIGNORE=".git"
  cd "$repo_root"
  files=(*)
  if [[ "${#files[@]}" -eq 0 ]]; then
    exit 0
  fi
  if cp -cR -- "${files[@]}" "$worktree_dir"/ 2>/dev/null; then
    :
  elif cp --reflink=auto -a -- "${files[@]}" "$worktree_dir"/ 2>/dev/null; then
    :
  else
    cp -a -- "${files[@]}" "$worktree_dir"/
  fi
)

completed=true
printf '%s\n' "$worktree_dir"
